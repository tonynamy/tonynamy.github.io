---
title: 11월 5주차
categories: [회고]
tags: [회고, 알고리즘]
---

11월 5주차 회고를 한 번 해보려고 한다. 크게 좀 정리를 해 보자면

- PS 노트
- JLPT 시험
- CNU 인수 인계

정도가 있었던 것 같다.

# PS 노트

이전부터 PS 노트를 조금씩 작성 해오고 있었긴 한데, 매일 한 문제는 풀어야지, 하고 안풀었던 것 같다. 그래서 이번에는 사람들을 좀 모아서 매일 한 문제씩 풀어 노션에 노트를 작성하고, 안 푼 사람은 5천원씩 걷기로 했다.

![현재까지의 PS 노트 현황](/assets/images/2022-12-06-12-52-33.png)
_현재까지의 PS 노트 현황_

## 세그먼트 트리

작년부터 공부하려고 했었던 세그먼트 트리 공부를 이제서야 시작했다.

![세그먼트 트리 처음 풀었을 때](/assets/images/2022-12-06-14-55-17.png)
_세그먼트 트리 처음 풀었을 때_

세그먼트 트리를 처음 풀었을 때 코드에 작성해 둔 주석이다. 배열의 절반씩 나눠서 부분을 대표하는 값(혹은 부분합)을 저장한다고 생각하면 된다. 절반씩 나누기 때문에 아래와 같은 시간 복잡도를 가진다.

| Operation          | 시간복잡도 |
| ------------------ | ---------- |
| 특정 원소 업데이트 | O(log N)   |
| 특정 구간 탐색     | O(log N)   |

아래는 특정 원소 업데이트를 하는 세그먼트 트리의 C++ 코드이다. 주의해야할 점은 세그먼트 트리의 한 원소는 항상 우리가 표현하고자 하는 배열 구간을 대표하는 값을 가진다는 것이고, 어떤 구간을 대표하는 값을 수정하면 그 경로에 있는 모든 노드가 업데이트 된다는 점이다.

```c++
/**
 * @brief 세그먼트 트리의 특정 원소를 수정하는 함수
 *
 * @param t 세그먼트 트리
 * @param s (세그먼트 트리가 대표하는) 배열의 왼쪽 인덱스
 * @param e (세그먼트 트리가 대표하는) 배열의 오른쪽 인덱스
 * @param i 세그먼트 트리의 인덱스
 * @param u 수정하고자 하는 배열의 인덱스
 * @param v 수정하고자 하는 배열의 값
 *
 */
void updateTree(vector<int> &t, int i, int s, int e, int u, int v) {

  if(e < u || s > u) return;

  t[i] += v;

  if(s==e) return;

  int m = (s+e)/2;

  updateTree(t, i*2, s, m, u, v);
  updateTree(t, i*2+1, m+1, e, u, v);

}
```

같은 논리로 세그먼트 트리가 나타내는 배열의 구간 합은 아래의 함수로 구할 수 있다.

```c++
/**
 * @brief 세그먼트 트리의 특정 구간을 조회하는 함수
 *
 * @param t 세그먼트 트리
 * @param s (세그먼트 트리가 대표하는) 배열의 왼쪽 인덱스
 * @param e (세그먼트 트리가 대표하는) 배열의 오른쪽 인덱스
 * @param i 세그먼트 트리의 인덱스
 * @param l 조회하고자 하는 배열의 시작 인덱스
 * @param r 조회하고자 하는 배열의 종료 인덱스
 *
 * @return int
 *
 */
int queryTree(vector<int> &t, int i, int s, int e, int l, int r) {

  if(e < u || s > u) return 0; // default 값 반환 (문제에 따라 변경)

  if(l <= s && e <= r) return t[i];

  int m = (s+e)/2;

  return queryTree(t, i*2, s, m, l, r) + queryTree(t, i*2+1, m+1, e, l, r);

}
```

세그먼트 트리는 부분 합을 구할 때만 사용되는 것이 아니라 특정 구간을 대표하는 값이 필요할 때 모두 사용할 수 있다. 그렇기에 부분합을 구하는 방법만을 연습하는 것이 아니라 `default` 값을 적절히 조절하거나 `queryTree`의 최하단 부분을 적절히 변형하는 연습도 좋을 것 같다.

이래 문제들이 `queryTree`를 적절히 변형해서 풀었던 문제들이다.

- [1725 히스토그램](https://www.acmicpc.net/problem/1725)
- [2243 사탕상자](https://www.acmicpc.net/problem/2243)
- [2336 굉장한 학생](https://www.acmicpc.net/problem/2336)

## Lazy Propagation

위에서 설명한 세그먼트의 시간 복잡도에 따르면 특정 인덱스의 원소를 수정하는데에 `O(log N)`의 시간이 걸림을 알 수 있었다. 그런데 만약 특정 구간을 업데이트 해야한다면 어떻게 될까? 구간의 크기를 `M`이라고 한다면 간단하게 생각했을 때 `O(M log N)`임을 알 수 있다.

그런데, 만약 전체 구간을 업데이트 하는 쿼리를 수행해야 한다면 어떨까? 기존의 업데이트 코드를 응용하면 아래와 같이 '구간'을 업데이트 하는 코드를 짤 수 있는데 그냥 생각만 해보더라도 세그먼트 트리의 모든 노드들의 값을 수정해야 하기 때문에 엄청난 시간이 소요될 것을 에측할 수 있다.

```c++
/**
 * @brief 세그먼트 트리의 특정 원소를 수정하는 함수
 *
 * @param t 세그먼트 트리
 * @param s (세그먼트 트리가 대표하는) 배열의 왼쪽 인덱스
 * @param e (세그먼트 트리가 대표하는) 배열의 오른쪽 인덱스
 * @param i 세그먼트 트리의 인덱스
 * @param l 수정하고자 하는 배열의 시작 인덱스
 * @param r 수정하고자 하는 배열의 종료 인덱스
 * @param v 수정하고자 하는 배열의 값
 *
 */
void updateTree(vector<int> &t, int i, int s, int e, int l, int r, int v) {

  if(e < l || s > r) return;

  if(s==e) {
    t[i] += v;
    return;
  }

  int m = (s+e)/2;

  updateTree(t, i*2, s, m, l, r, v);
  updateTree(t, i*2+1, m+1, e, l, r, v);

  t[i] = t[i*2] + t[i*2+1];
}
```

우리는 특정 `구간`의 대표값을 구하기 위해서 세그먼트 트리를 사용하고 있다. 그 말인즉슨, 우리가 구하지 않는 구간에 대해서는 업데이트를 수행할 필요가 없다는 뜻이다.

```
a b c d e f g
-A- -B- -C- -D-
---E--- ---F---
-------G-------
```

세그먼트 트리는 다음과 같이 생각할 수 있다고 했다. `a~b` 구간의 대표값은 `A`이고, `c~d` 구간의 대표값은 `B`이고 ... 전체 구간의 대표값은 `G`가 된다. 우리가 만약 전체 구간에 대해서 +1 연산을 해야한다면 `a`, `b`, ..., `g`, `A`, `B`, ..., `G` 에 해당하는 모든 노드에 +1을 해주어야 한다. 그런데 만약, 쿼리는 `c~e`구간만 하고 있다면 어떨까? `c~e` 구간의 대표값을 찾기 위해서 탐색을 거치는 과정을 생각해보면, `c~d`의 대표값을 찾기 위하여 `G`->`E`->`B`, `e`의 값을 찾기 위하여 `G`->`F`->`C`->`e`의 경로를 거침을 알 수 있다. 따라서 방금 언급한 경로에 해당하는 노드들을 제외하면 굳이 업데이트를 해주지 않아도 된다는 뜻이다.

이 때 Lazy Propagation 전략을 사용한다. Lazy Propagation이란 업데이트 처리를 바로 하지 않고, 노드가 탐색 당한 순간에 업데이트를 하겠다는 이야기이다. 즉 쿼리를 수행함에 있어서 필요없는 노드들은 업데이트를 하지 않겠다는 의미라고도 볼 수 있다. 각 노드의 `업데이트가 필요하다는 표식`을 걸어준다고 생각하면 되는데, 아까의 예에 대입해보면 전체 구간을 나타내는 G에 \*라는 업데이트 표식을 남긴다고 생각하면 된다.

```
a b c d e f g
-A- -B- -C- -D-
---E--- ---F---
-------G*------
```

그럼 이제 `c~e` 구간을 조회해보자. `G` 노드를 조회하면 업데이트 표식이 있으므로 자신의 자식들에게 해당 표식을 전파하고, 자신의 값을 업데이트 시킨다.

```
a b c d e f g
-A- -B- -C- -D-
---E*-- ---F*--
-------G------
```

같은 논리로, `c~e` 구간을 조회하면 해당 구간을 조회하기 위하여 방문한 노드들에는 모두 값이 업데이트 되어있을 것이고, 조회를 함에 있어 필요하지 않았던 노드들은 업데이트 표식만을 가지게 될 것이다.

```
a b c d e f g
-A* -B- -C- -D*
---E--- ---F---
-------G------
```

그럼 이제 고민해야 될 것은 업데이트 표식에 어떤 값을 주어야 하는가다. 일반적으로 업데이트 표식에는 업데이트를 해주어야 하는 값을 저장한다.

## 오일러 경로 테크닉

## 위상 정렬

# JLPT

# CNU 인수 인계
